module Skel
  use int.Int
  use bool.Bool
  use real.RealInfix
  use option.Option

  (*clone field.Intf as V with axiom equal_is_eq*)
  use interval.BoundInterval
  scope Make
  use array.Array
  type u = {
    unbound_down : option V.t;
    unbound_up : option V.t;
    bound : array bound_interval
  } invariant {
    (forall j. 0 <= j < bound.length - 1 -> before_interval bound[j] bound[j+1])
    /\
    bound.length > 0 ->
      match unbound_down with
      | None -> true
      | Some x -> V.(x <= bound[0].lower)
      end
      /\
      match unbound_up with
      | None -> true
      | Some x ->
          let lst = bound[bound.length - 1] in
          V.(lst.upper <= x)
      end
  }
  (* just some unsound placeholders *)
  predicate _fmla
  val _code () : u
    ensures { false }
  val _codeb () : bool
    ensures { false }

  let x : real = 1.0

  predicate mem (x:real) (l:u) =
    match l.unbound_down with
    | None -> false
    | Some y -> x <. y.V.real
    end
    \/
    match l.unbound_up with
    | None -> false
    | Some y -> x >. y.V.real
    end
    \/
    exists i. 0 <= i < l.bound.length /\ mem_r_interval x l.bound[i]

  let signleton (q:V.t) : u
    ensures { forall x. mem x result <-> q.V.real = x }
  =
    let r = {
      unbound_down = None; unbound_up = None;
      bound = Array.make 1 (singleton_mk q)
    } in
    begin (* these hints are not necessary but make AltErgo faster for this specif *)
      assert { forall x. (mem x r <-> mem_r_interval x (singleton_mk q))};
      assert { forall x. (mem_r_interval x (singleton_mk q)) <-> x = q};
      r
    end

  let gt (q:V.t) : u
    ensures { forall x. mem x result <-> x >. q.V.real }
  =
    {unbound_down = None; bound = Array.empty ();
     unbound_up = Some q}

  let ge (q:V.t) : u
    ensures { _fmla } = _code ()

  let except (x:V.t) : u
    ensures { _fmla } = _code ()

  let inter (u:u) (v:u) : u
    ensures { _fmla } = _code ()

  let union (u:u) (v:u) : u
    ensures { _fmla } = _code ()

  let subset (u:u) (v:u) : bool
    ensures { _fmla } =  _codeb ()

  let disjoint (u:u) (v:u) : bool
    ensures { _fmla } = _codeb ()
end
end
