module BoundInterval
  use int.Int
  use bool.Bool
  use real.RealInfix
  use option.Option
  clone field.Intf as V with axiom equal_is_eq


  type bound_interval = {
    lower : V.t;
    upper : V.t;
    lower_closed : bool;
    upper_closed : bool
  } invariant {
      V.(<=) lower upper /\
      (V.(<) lower upper \/ (lower_closed /\ upper_closed))
  } by { lower=V.non_empty; upper=V.non_empty; lower_closed=true; upper_closed=true }

  predicate mem_r_interval (e : real) (i : bound_interval) =
       i.lower.V.real <. e <. i.upper.V.real
    \/ (i.lower_closed /\ e = i.lower.V.real)
    \/ (i.upper_closed /\ e = i.upper.V.real)

  let predicate mem_interval (e : V.t) (i : bound_interval) =
     V.(orb (i.lower < e < i.upper) (orb
       (andb i.lower_closed (e = i.lower))
       (andb i.upper_closed (e = i.upper))))

  predicate incl_r_interval (i j : bound_interval) =
    forall e. mem_r_interval e i -> mem_r_interval e j

  let function incl_interval (i j : bound_interval) : bool
  = any bool ensures {
      result <-> V.(
            j.lower <= i.lower
         /\ i.upper <= j.upper
         /\ (i.upper = j.upper -> i.upper_closed -> j.upper_closed)
         /\ (i.lower = j.lower -> i.lower_closed -> j.lower_closed)
      )
    }

  predicate disj_r_interval (i j : bound_interval) =
    forall x. not mem_r_interval x i \/ not mem_r_interval x j

  let predicate before_interval (i j : bound_interval)
  = any bool ensures {
      result <-> V.(i.upper < j.lower
      \/
      (i.upper = j.lower /\ not(i.upper_closed /\ j.lower_closed)))
    }
  lemma interval_r_nonempy :
    forall i: bound_interval. exists x. mem_r_interval x i

  lemma incl_interval_charac :
    forall i j : bound_interval.
      incl_r_interval i j
      <->
      incl_interval i j

  lemma before_disj_r_interval : forall i j : bound_interval.
    (before_interval i j \/ before_interval j i) <-> disj_r_interval i j

  let predicate strt_before_interval (i j : bound_interval) : bool
  = any bool ensures {
    result <-> V.(
      i.lower < j.lower ||
      (i.lower = j.lower && (i.lower_closed || not j.lower_closed))
    )}
  let predicate (<==) = strt_before_interval

  lemma strt_before_linear : forall i j. i <== j \/ j <== i

  let predicate end_after_interval (i j : bound_interval)
  = any bool ensures {
      result <-> V.(
        j.upper < i.upper ||
        (i.upper = j.upper && (i.upper_closed || not j.upper_closed))
    )}
  let predicate (==>) = end_after_interval

  let predicate ends_after_starts (i j : bound_interval)
  = any bool ensures {
      result <-> V.(
        j.lower < i.upper ||
        (i.upper = j.lower && (i.upper_closed && j.lower_closed))
    )}
  let predicate (<.>) = ends_after_starts

  let function ndisj_interval (i j : bound_interval) : bool
  = any bool ensures {
    result <-> V.(
      let (i, j) = if strt_before_interval i j then (i, j) else (j, i) in
         j.lower <= i.upper
      && (i.upper = j.lower -> i.upper_closed && j.lower_closed)
    )
  }

  lemma ndisj_carac : forall i j :
     bound_interval. ndisj_interval i j <-> not (disj_r_interval i j)

  let function merge_intervals (i j : bound_interval) : bound_interval
    requires { ndisj_interval i j }
    ensures { forall x. mem_r_interval x result <->
                        mem_r_interval x i \/ mem_r_interval x j }
    ensures { let k = if i <== j then i else j in
              result.lower = k.lower /\ result.lower_closed = k.lower_closed }
    ensures { let k = if i ==> j then i else j in
              result.upper = k.upper /\ result.upper_closed = k.upper_closed }
  =
    let (i, j) = if i <== j then (i, j) else (j, i) in
    let lst = if i ==> j then i else j in
    {lower=i.lower; lower_closed=i.lower_closed;
     upper=lst.upper; upper_closed=lst.upper_closed}

  let function inter_intervals (i j : bound_interval) : bound_interval
    requires { ndisj_interval i j }
    ensures { forall x. mem_r_interval x result <->
                        mem_r_interval x i /\ mem_r_interval x j }
    ensures { let k = if i <== j then j else i in
              result.lower = k.lower /\ result.lower_closed = k.lower_closed }
    ensures { let k = if i ==> j then j else i in
              result.upper = k.upper /\ result.upper_closed = k.upper_closed }
  =
    let nf, nl = (if i <== j then j else i), (if i ==> j then j else i) in
    {lower=nf.lower; lower_closed=nf.lower_closed;
     upper=nl.upper; upper_closed=nl.upper_closed}

  let predicate (<<) i j = before_interval i j
  let function (++) = merge_intervals
  let function (^^) = inter_intervals

  (*lemma tmp0 : forall i j. ndisj_interval i j <-> ndisj_interval j i*)

  lemma incl_interval_ext : forall i j. incl_interval i j /\ incl_interval j i ->
    i = j by bound_interval'eq i j

  let lemma merge_intervals_comm (i j : bound_interval) : unit
    requires { ndisj_interval i j }
    ensures { i++j=j++i
              by incl_r_interval(i++j)(j++i)/\incl_r_interval(j++i)(i++j) } = ()

  let lemma inter_intervals_comm (i j : bound_interval) : unit
    requires { ndisj_interval i j }
    ensures { i^^j=j^^i
              by incl_r_interval(i^^j)(j^^i)/\incl_r_interval(i^^j)(j^^i) } = ()

  let lemma merge_union_comp_order (i j k: bound_interval)
    requires { ndisj_interval i j }
    ensures { (k << i /\ k << j) -> k << (i++j) /\ k << (i^^j) }
    ensures { (i << k /\ j << k) -> (i++j) << k /\ (i^^j) << k}
  = ()

let lemma merge_union_comp_order' (i j k: bound_interval)
    requires { ndisj_interval i j }
    ensures { (k <== i /\ k <== j) -> k <== (i++j) /\ k <== (i^^j) }
    ensures { (i <== k /\ j <== k) -> (i++j) <== k /\ (i^^j) <== k}
  = ()

  let function __mk_interval lb l ub u
    requires { V.(l <= u) /\ (l = u -> ub /\ lb) }
  = { lower_closed=lb; lower=l; upper_closed=ub; upper=u }

  let function clo_clo_mk a b
    requires { V.(a <= b) }
    ensures { forall x. mem_r_interval x result -> a.V.real <=. x <=. b.V.real }
  = __mk_interval true a true b

  let function clo_opn_mk a b
    requires { V.(a < b) }
    ensures { forall x. mem_r_interval x result -> a.V.real <=. x <. b.V.real }
  = __mk_interval true a false b

  let function opn_clo_mk a b
    requires { V.(a < b) }
    ensures { forall x. mem_r_interval x result -> a.V.real <. x <=. b.V.real }
  = __mk_interval false a true b

  let function singleton_mk a
    ensures { forall x. mem_r_interval x result <-> x = a.V.real }
  = clo_clo_mk a a

  lemma before_interval_trans : forall i j k.
    before_interval i j -> before_interval j k -> before_interval i k

  lemma starts_before_trans : forall i j k.
    i <== j /\ j <== k -> i <== k

  lemma order_mix_trans : forall i j k.
    i << j /\ j <== k -> i << k

  clone array_utils.ArraySort as LaxS
        with type elt = bound_interval, predicate le = (<==), val le = (<==)

end




module BoundUnion
  use BoundInterval
  use int.Int
  use array.Array
  use array_utils.ArrayUtils
  use exn.Exn

  type bound_union = {
     a : array bound_interval
  } invariant {
    forall j. 0 <= j < a.length - 1 -> before_interval a[j] a[j+1]
  }

  type lax_bound_union = {
     lax_a : array bound_interval
  } invariant {
    let a = lax_a in
    forall j. 0 <= j < a.length - 1 -> lax_a[j] <== lax_a[j+1]
  }

  let predicate gen_mem_sub_union (x:real) (a:array bound_interval) (i j:int)
    requires { 0 <= i <= j <= a.length }
  = any bool ensures {result <-> exists k. i <= k < j /\ mem_r_interval x a[k]}

  predicate gen_mem_union (x:real) (a:array bound_interval) =
    exists j. 0 <= j < a.length /\ mem_r_interval x a[j]

  predicate lax_mem_union (x:real) (lbu : lax_bound_union) =
    gen_mem_union x lbu.lax_a

  predicate mem_union (x:real) (bu : bound_union) =
    gen_mem_union x bu.a

  let lemma replace_mem_union (x:real) (a new:array bound_interval) (i j:int)
    requires { 0 <= i <= j <= length a }
    requires { gen_mem_sub_union x a i j <-> gen_mem_union x new }
    ensures { gen_mem_union x (replace a new i j) <-> gen_mem_union x a }
  = ()

  let rec lemma all_before (bu : bound_union) (i j : int) : unit
    requires { 0 <= i < j < bu.a.length }
    ensures { bu.a[i] << bu.a[j] }
    variant { j - i }
  = if j = i+1 then () else all_before bu (i+1) j

  let rec lemma lax_all_before (bu : lax_bound_union) (i j : int) : unit
    requires { 0 <= i < j < bu.lax_a.length }
    ensures { bu.lax_a[i] <== bu.lax_a[j] }
    variant { j - i }
  = if j = i+1 then () else lax_all_before bu (i+1) j

  lemma mem_union_unique :
    forall x. forall bu. forall i. 0 <= i < bu.a.length -> mem_r_interval x bu.a[i] ->
      forall j. 0 <= j < i \/ i < j < bu.a.length -> not mem_r_interval x bu.a[j]

  let function lax_inj (bu : bound_union) : lax_bound_union
    ensures {forall x. mem_union x bu <-> lax_mem_union x result}
  = { lax_a = bu.a }

  let function lax_merge (lbu: lax_bound_union) (i : int) : lax_bound_union
    requires { 0 <= i < lbu.lax_a.length - 1}
    requires { lbu.lax_a[i] <.> lbu.lax_a[i+1] }
    ensures { result.lax_a.length = lbu.lax_a.length - 1 }
    ensures { forall x. lax_mem_union x result <-> lax_mem_union x lbu }
    ensures { forall j. 0 <= j < i -> result.lax_a[j] = lbu.lax_a[j] }
    ensures { forall j. i+1 <= j < lbu.lax_a.length - 1 ->
              result.lax_a[j] = lbu.lax_a[j+1] }
    ensures { result.lax_a[i] = lbu.lax_a[i]++lbu.lax_a[i+1] }
  =
    begin (* i'm not sure these make the proof quicker *)
      (*let j = i+1 in
      assert { V.(lbu.lax_a[i].lower<=lbu.lax_a[j].lower<=lbu.lax_a[j].upper) };
      assert { V.(lbu.lax_a[j].lower <= lbu.lax_a[j].upper) };
      assert { not V.(lbu.lax_a[Int.(i+1)].upper < lbu.lax_a[i].lower) };
      assert { not (before_interval lbu.lax_a[i+1] lbu.lax_a[i]) }*)
    end;
    let na = replace_by_one lbu.lax_a (lbu.lax_a[i]++lbu.lax_a[i+1]) i (i+2) in
    { lax_a = na }

  let lemma relating_orders (i j : bound_interval)
    ensures {(i<==j /\ not (i<.>j)) -> i << j} = ()

  let lax_to_strict (lbu : lax_bound_union) : bound_union
    ensures { forall x. mem_union x result <-> lax_mem_union x lbu }
  =
    let ref i = 0 in
    let ref tmp = { lax_a = copy lbu.lax_a } in
    while i < tmp.lax_a.length - 1 do
      variant { tmp.lax_a.length - i }
      invariant { 0 <= i }
      (* we need to assure why3 that the type invariant is preserved *)
      invariant { forall j. 0 <= j < tmp.lax_a.length - 1 ->
                  tmp.lax_a[j] <== tmp.lax_a[j+1] }
      invariant { forall j. 0 <= j < i -> tmp.lax_a[j] << tmp.lax_a[j+1] }
      invariant { forall x. lax_mem_union x lbu <-> lax_mem_union x tmp }

      assert { not tmp.lax_a[i]<.>tmp.lax_a[i+1] -> tmp.lax_a[i] << tmp.lax_a[i+1] };
      if tmp.lax_a[i] <.> tmp.lax_a[i+1] then
        begin
        assert { tmp.lax_a[i] <== tmp.lax_a[i+1] };
        assert { i-1 >= 0 -> tmp.lax_a[i-1] << tmp.lax_a[i] };
        assert { i-1 >= 0 -> tmp.lax_a[i-1] << tmp.lax_a[i+1] };
        tmp <- lax_merge tmp i;
        assert { i-1 >= 0 -> tmp.lax_a[i-1] << tmp.lax_a[i] };
        end
      else
        i <- i + 1
    done;
    { a = tmp.lax_a }

  let lax_add_interval (int : bound_interval) (bu: lax_bound_union) : lax_bound_union
    ensures { forall x. lax_mem_union x result
                    <-> lax_mem_union x bu \/ mem_r_interval x int }
  =
    let ref i = 0 in
    while i < bu.lax_a.length && not int <== bu.lax_a[i] do
      variant { bu.lax_a.length - i }
      invariant { 0 <= i <= bu.lax_a.length}
      invariant { i > 0 -> bu.lax_a[i-1] <== int }
      i <- i+1
    done;
    { lax_a = insert int bu.lax_a i }

  let lax_union_union (bu bu' : lax_bound_union) : lax_bound_union
    ensures { forall x. lax_mem_union x result
                    <-> lax_mem_union x bu \/ lax_mem_union x bu' }
  =
    let ref i = 0 in
    let ref tmp = {lax_a = copy bu.lax_a} in
    while i < length bu'.lax_a do
      variant { length bu'.lax_a - i }
      invariant { 0 <= i <= length bu'.lax_a }
      invariant { forall j. 0 <= j < length tmp.lax_a - 1 ->
                  tmp.lax_a[j]<==tmp.lax_a[j+1] }
      invariant { forall x. lax_mem_union x tmp <->
                            lax_mem_union x bu \/ gen_mem_sub_union x bu'.lax_a 0 i}
      tmp <- lax_add_interval bu'.lax_a[i] tmp;
      i <- i + 1
    done;
    tmp

  let union_union (bu bu' : bound_union) : bound_union
    ensures { forall x. mem_union x result
                    <-> mem_union x bu \/ mem_union x bu' }
  =
    lax_to_strict (lax_union_union (lax_inj bu) (lax_inj bu'))

  let array_to_lax_bound_union (a : array bound_interval) : lax_bound_union
    ensures { forall x. gen_mem_union x a <-> lax_mem_union x result }
  = { lax_a = LaxS.sort a }

  let lax_bound_union_to_array (lu: lax_bound_union) : array bound_interval
    ensures { forall x. gen_mem_union x result <-> lax_mem_union x lu }
  = lu.lax_a

  let gen_inter_interval (int : bound_interval) (a : array bound_interval) : array bound_interval
    ensures { forall x. gen_mem_union x result
                    <-> gen_mem_union x a /\ mem_r_interval x int }
  =
    let ref i = 0 in
    let ref tmp = make 0 (singleton_mk V.non_empty) in
    while i < length a do
      variant { length a - i }
      invariant { 0 <= i <= length a }
      invariant { forall x. gen_mem_union x tmp <->
                            gen_mem_sub_union x a 0 i /\ mem_r_interval x int }
      if ndisj_interval int a[i] then
        let inter = int ^^ a[i] in tmp <- replace_by_one tmp inter (length tmp) (length tmp)
      else ();
      i <- i + 1
    done;
    tmp

  let inter_interval (int : bound_interval) (bu : bound_union) : bound_union
    ensures { forall x. mem_union x result <->
                        mem_union x bu /\ mem_r_interval x int }
  =
    let gen_bu = lax_bound_union_to_array (lax_inj bu) in
    let res = gen_inter_interval int gen_bu in
    lax_to_strict (array_to_lax_bound_union res)

  let inter_union (bu bu' : bound_union) : bound_union
    ensures { forall x. mem_union x result <->
                        mem_union x bu /\ mem_union x bu' }
  =
    let ref result = { a = empty () } in
    for i = 0 to bu'.a.length - 1 do
      invariant { forall x. mem_union x result <->
                            mem_union x bu /\ gen_mem_sub_union x bu'.a 0 i }
      result <- union_union result (inter_interval bu'.a[i] bu)
    done;
    result
end

