module BoundInterval
  use int.Int
  use bool.Bool
  use real.RealInfix
  use option.Option
  clone field.Intf as V with axiom equal_is_eq


  type bound_interval = {
    lower : V.t;
    upper : V.t;
    lower_closed : bool;
    upper_closed : bool
  } invariant {
      V.(<=) lower upper /\
      (V.(<) lower upper \/ (lower_closed /\ upper_closed))
  } by { lower=V.non_empty; upper=V.non_empty; lower_closed=true; upper_closed=true }



  predicate mem_r_interval (e : real) (i : bound_interval) =
       i.lower.V.real <. e <. i.upper.V.real
    \/ (i.lower_closed /\ e = i.lower.V.real)
    \/ (i.upper_closed /\ e = i.upper.V.real)

  let predicate mem_interval (e : V.t) (i : bound_interval) =
     V.(orb (i.lower < e < i.upper) (orb
       (andb i.lower_closed (e = i.lower))
       (andb i.upper_closed (e = i.upper))))

  predicate incl_r_interval (i j : bound_interval) =
    forall e. mem_r_interval e i -> mem_r_interval e j

  let function incl_interval (i j : bound_interval) : bool
  = any bool ensures {
      result <-> V.(
            j.lower <= i.lower
         /\ i.upper <= j.upper
         /\ (i.upper = j.upper -> i.upper_closed -> j.upper_closed)
         /\ (i.lower = j.lower -> i.lower_closed -> j.lower_closed)
      )
    }

  predicate disj_r_interval (i j : bound_interval) =
    forall x. not mem_r_interval x i \/ not mem_r_interval x j

  let predicate before_interval (i j : bound_interval)
  = any bool ensures {
      result <-> V.(i.upper < j.lower
      \/
      (i.upper = j.lower /\ not(i.upper_closed /\ j.lower_closed)))
    }
  lemma interval_r_nonempy :
    forall i: bound_interval. exists x. mem_r_interval x i

  lemma incl_interval_charac :
    forall i j : bound_interval.
      incl_r_interval i j
      <->
      incl_interval i j

  lemma before_disj_r_interval : forall i j : bound_interval.
    (before_interval i j \/ before_interval j i) <-> disj_r_interval i j

  let predicate strt_before_interval (i j : bound_interval) : bool
  = any bool ensures {
    result <-> V.(
      i.lower < j.lower ||
      (i.lower = j.lower && (i.lower_closed || not j.lower_closed))
    )}
  let predicate (<==) = strt_before_interval

  lemma strt_before_linear : forall i j. i <== j \/ j <== i

  let predicate end_after_interval (i j : bound_interval)
  = any bool ensures {
      result <-> V.(
        j.upper < i.upper ||
        (i.upper = j.upper && (i.upper_closed || not j.upper_closed))
    )}
  let predicate (==>) = end_after_interval

  let function ndisj_interval (i j : bound_interval) : bool
  = any bool ensures {
    result <-> V.(
      let (i, j) = if strt_before_interval i j then (i, j) else (j, i) in
         j.lower <= i.upper
      && (i.upper = j.lower -> i.upper_closed && j.lower_closed)
    )
  }

  lemma ndisj_carac : forall i j :
     bound_interval. ndisj_interval i j <-> not (disj_r_interval i j)

  let function merge_intervals (i j : bound_interval) : bound_interval
    requires { ndisj_interval i j }
    ensures { forall x. mem_r_interval x result <->
                        mem_r_interval x i \/ mem_r_interval x j }
    ensures { let k = if i <== j then i else j in
              result.lower = k.lower /\ result.lower_closed = k.lower_closed }
    ensures { let k = if i ==> j then i else j in
              result.upper = k.upper /\ result.upper_closed = k.upper_closed }
  =
    let (i, j) = if i <== j then (i, j) else (j, i) in
    let lst = if i ==> j then i else j in
    {lower=i.lower; lower_closed=i.lower_closed;
     upper=lst.upper; upper_closed=lst.upper_closed}

  let predicate (<<) i j = before_interval i j
  let function (++) = merge_intervals

  lemma tmp0 : forall i j. ndisj_interval i j <-> ndisj_interval j i
  let lemma tmp1 (i j : bound_interval)
    requires { incl_r_interval i j }
    requires { incl_r_interval j i }
    ensures { true \/ i = j }
  =
    assert { V.(i.lower <= j.lower /\ j.lower <= i.lower) };
    assert { V.(i.upper <= j.upper /\ j.upper <= i.upper) };
    assert { V.(i.upper = j.upper /\ i.lower = j.lower) };
    assert { i.upper_closed = j.upper_closed }
  let lemma tmp (i j k : bound_interval)
    requires { k << i } requires { k << j }
    ensures { true \/ k << (i++j) }
  = ()
  let lemma merge_comp_order (i j k: bound_interval)
    requires { ndisj_interval i j }
    (*ensures { (k << i /\ k << j) -> k << (i++j) }
    ensures { (i << k /\ j << k) -> (i++j) << k }*)
  =
    if i <== j then
      assert { (i++j).lower = i.lower /\ (i++j).lower_closed = i.lower_closed }
    else
      assert { j <== i }
      (*assert { (i++j).lower = j.lower /\ (i++j).lower_closed = j.lower_closed }*)

  let function __mk_interval lb l ub u
    requires { V.(l <= u) /\ (l = u -> ub /\ lb) }
  = { lower_closed=lb; lower=l; upper_closed=ub; upper=u }

  let function clo_clo_mk a b
    requires { V.(a <= b) }
    ensures { forall x. mem_r_interval x result -> a.V.real <=. x <=. b.V.real }
  = __mk_interval true a true b

  let function clo_opn_mk a b
    requires { V.(a < b) }
    ensures { forall x. mem_r_interval x result -> a.V.real <=. x <. b.V.real }
  = __mk_interval true a false b

  let function opn_clo_mk a b
    requires { V.(a < b) }
    ensures { forall x. mem_r_interval x result -> a.V.real <. x <=. b.V.real }
  = __mk_interval false a true b

  let function singleton_mk a
    ensures { forall x. mem_r_interval x result <-> x = a.V.real }
  = clo_clo_mk a a

  lemma before_interval_trans : forall i j k.
    before_interval i j -> before_interval j k -> before_interval i k


end




module BoundUnion
  use BoundInterval
  use int.Int
  use array.Array
  use array_utils.ArrayUtils
  use exn.Exn

  type bound_union = {
     a : array bound_interval
  } invariant {
    forall j. 0 <= j < a.length - 1 -> before_interval a[j] a[j+1]
  }

  type lax_bound_union = {
     lax_a : array bound_interval
  } invariant {
    let a = lax_a in
    forall j. 0 <= j < a.length - 1 ->
       V.(a[j].lower <= a[Int.(j+1)].lower) /\
       V.(a[j].lower = a[Int.(j+1)].upper) -> a[j+1].lower_closed -> a[j].lower_closed
  }

  predicate lax_mem_union (x:real) (lbu : lax_bound_union) =
    exists j. 0 <= j < lbu.lax_a.length /\ mem_r_interval x lbu.lax_a[j]

  let function lax_inj (bu : bound_union) : lax_bound_union =
    { lax_a = bu.a }

  (*let function lax_merge (lbu: lax_bound_union) (i : int) : lax_bound_union
    requires { 0 <= i < lbu.lax_a.length - 1}
    requires { V.(lbu.lax_a[Int.(i+1)].lower < lbu.lax_a[i].upper) }
    ensures { result.lax_a.length = lbu.lax_a.length - 1 }
    ensures { forall x. lax_mem_union x result <-> lax_mem_union x lbu }
  = lbu
    (*let merge = {
      lower=lbu.lax_a[i].lower;
      upper=max lbu.lax_a[i].upper;
      lower_closed=lax_a[i].lower_closed;
      upper_closed=*)*)

  predicate mem_union (x:real) (bu : bound_union) =
    exists j. 0 <= j < bu.a.length /\ mem_r_interval x bu.a[j]

  let rec lemma all_before (bu : bound_union) (i j : int) : unit
    requires { 0 <= i < j < bu.a.length }
    ensures { before_interval bu.a[i] bu.a[j] }
    variant { j - i }
  = if j = i+1 then () else all_before bu (i+1) j


  lemma mem_union_unique :
    forall x. forall bu. forall i. 0 <= i < bu.a.length -> mem_r_interval x bu.a[i] ->
      forall j. 0 <= j < i \/ i < j < bu.a.length -> not mem_r_interval x bu.a[j]

  let function add_interval (int : bound_interval) (bu : bound_union) : bound_union
    ensures { true \/ (forall x. mem_union x result
                   <-> (mem_union x bu \/ mem_r_interval x int)) }
  =
    exception Return (array bound_interval) in
    try
      for i = 0 to bu.a.length - 1 do
        invariant { forall j. 0 <= j < i -> before_interval bu.a[i-1] int }
        if before_interval int bu.a[i] then
           let t = insert int bu.a i in
           assert { i > 0 -> before_interval t[i-1] t[i] }; (* quicker *)
           assert { forall j. 0 <= j < bu.a.length -> before_interval t[j] t[j+1] };
           raise (Return t)
        else if incl_interval bu.a[i] int then
           let t = copy bu.a in
           t[i] <- int;
           raise (Return t)
        else if incl_interval int bu.a[i] then
           raise (Return (copy bu.a))
        else if not (before_interval bu.a[i] int) then
           raise (Return (empty())); (* TODO *)
        assert {before_interval bu.a[i] int};
      done;
      raise (Return (insert int bu.a bu.a.length));
    with Return t -> { a = empty() }
    end;

    (*
       Plan:
        - lax unions
        - mem for lax unions
        - add interval to lax unions
        - merge lax union to get equivalent strict union
        - intersect interval with lax union
        -
    *)
end

