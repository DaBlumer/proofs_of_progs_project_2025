module BoundInterval
  use int.Int
  use bool.Bool
  use real.RealInfix
  use option.Option
  clone field.Intf as V with axiom equal_is_eq


  type bound_interval = {
    lower : V.t;
    upper : V.t;
    lower_closed : bool;
    upper_closed : bool
  } invariant {
      V.(<=) lower upper /\
      (V.(<) lower upper \/ (lower_closed /\ upper_closed))
  } by { lower=V.non_empty; upper=V.non_empty; lower_closed=true; upper_closed=true }

  predicate mem_r_interval (e : real) (i : bound_interval) =
       i.lower.V.real <. e <. i.upper.V.real
    \/ (i.lower_closed /\ e = i.lower.V.real)
    \/ (i.upper_closed /\ e = i.upper.V.real)

  let predicate mem_interval (e : V.t) (i : bound_interval) =
     V.(orb (i.lower < e < i.upper) (orb
       (andb i.lower_closed (e = i.lower))
       (andb i.upper_closed (e = i.upper))))

  predicate incl_r_interval (i j : bound_interval) =
    forall e. mem_r_interval e i -> mem_r_interval e j

  let function incl_interval (i j : bound_interval) : bool
  = any bool ensures {
      result <-> V.(
            j.lower <= i.lower
         /\ i.upper <= j.upper
         /\ (i.upper = j.upper -> i.upper_closed -> j.upper_closed)
         /\ (i.lower = j.lower -> i.lower_closed -> j.lower_closed)
      )
    }

  predicate disj_r_interval (i j : bound_interval) =
    forall x. not mem_r_interval x i \/ not mem_r_interval x j

  let predicate before_interval (i j : bound_interval)
  = any bool ensures {
      result <-> V.(i.upper < j.lower
      \/
      (i.upper = j.lower /\ not(i.upper_closed /\ j.lower_closed)))
    }
  lemma interval_r_nonempy :
    forall i: bound_interval. exists x. mem_r_interval x i

  lemma incl_interval_charac :
    forall i j : bound_interval.
      incl_r_interval i j
      <->
      incl_interval i j

  lemma before_disj_r_interval : forall i j : bound_interval.
    (before_interval i j \/ before_interval j i) <-> disj_r_interval i j

  let predicate strt_before_interval (i j : bound_interval) : bool
  = any bool ensures {
    result <-> V.(
      i.lower < j.lower ||
      (i.lower = j.lower && (i.lower_closed || not j.lower_closed))
    )}
  let predicate (<==) = strt_before_interval

  lemma strt_before_linear : forall i j. i <== j \/ j <== i

  let predicate end_after_interval (i j : bound_interval)
  = any bool ensures {
      result <-> V.(
        j.upper < i.upper ||
        (i.upper = j.upper && (i.upper_closed || not j.upper_closed))
    )}
  let predicate (==>) = end_after_interval

  let predicate ends_after_starts (i j : bound_interval)
  = any bool ensures {
      result <-> V.(
        j.lower < i.upper ||
        (i.upper = j.lower && (i.upper_closed && j.lower_closed))
    )}
  let predicate (<.>) = ends_after_starts

  let function ndisj_interval (i j : bound_interval) : bool
  = any bool ensures {
    result <-> V.(
      let (i, j) = if strt_before_interval i j then (i, j) else (j, i) in
         j.lower <= i.upper
      && (i.upper = j.lower -> i.upper_closed && j.lower_closed)
    )
  }

  lemma ndisj_carac : forall i j :
     bound_interval. ndisj_interval i j <-> not (disj_r_interval i j)

  let function merge_intervals (i j : bound_interval) : bound_interval
    requires { ndisj_interval i j }
    ensures { forall x. mem_r_interval x result <->
                        mem_r_interval x i \/ mem_r_interval x j }
    ensures { let k = if i <== j then i else j in
              result.lower = k.lower /\ result.lower_closed = k.lower_closed }
    ensures { let k = if i ==> j then i else j in
              result.upper = k.upper /\ result.upper_closed = k.upper_closed }
  =
    let (i, j) = if i <== j then (i, j) else (j, i) in
    let lst = if i ==> j then i else j in
    {lower=i.lower; lower_closed=i.lower_closed;
     upper=lst.upper; upper_closed=lst.upper_closed}

  let predicate (<<) i j = before_interval i j
  let function (++) = merge_intervals

  (*lemma tmp0 : forall i j. ndisj_interval i j <-> ndisj_interval j i*)

  lemma incl_interval_ext : forall i j. incl_interval i j /\ incl_interval j i ->
    i = j by bound_interval'eq i j

  let lemma merge_intervals_comm (i j : bound_interval) : unit
    requires { ndisj_interval i j }
    ensures { i++j = j++i }
  =
    assert {incl_r_interval (i++j) (j++i)};
    assert {incl_r_interval (j++i) (i++j)}

  let lemma merge_comp_order_aux (i j k: bound_interval)
    requires { ndisj_interval i j }
    requires { k << i /\ k << j }
    ensures { k << (i++j) }
  = ()

  let lemma merge_comp_order (i j k: bound_interval)
    requires { ndisj_interval i j }
    ensures { (k << i /\ k << j) -> k << (i++j) }
    ensures { (i << k /\ j << k) -> (i++j) << k }
  = ()

  let function __mk_interval lb l ub u
    requires { V.(l <= u) /\ (l = u -> ub /\ lb) }
  = { lower_closed=lb; lower=l; upper_closed=ub; upper=u }

  let function clo_clo_mk a b
    requires { V.(a <= b) }
    ensures { forall x. mem_r_interval x result -> a.V.real <=. x <=. b.V.real }
  = __mk_interval true a true b

  let function clo_opn_mk a b
    requires { V.(a < b) }
    ensures { forall x. mem_r_interval x result -> a.V.real <=. x <. b.V.real }
  = __mk_interval true a false b

  let function opn_clo_mk a b
    requires { V.(a < b) }
    ensures { forall x. mem_r_interval x result -> a.V.real <. x <=. b.V.real }
  = __mk_interval false a true b

  let function singleton_mk a
    ensures { forall x. mem_r_interval x result <-> x = a.V.real }
  = clo_clo_mk a a

  lemma before_interval_trans : forall i j k.
    before_interval i j -> before_interval j k -> before_interval i k

  lemma order_mix_trans : forall i j k.
    i << j /\ j <== k -> i << k


end




module BoundUnion
  use BoundInterval
  use int.Int
  use array.Array
  use array_utils.ArrayUtils
  use exn.Exn

  type bound_union = {
     a : array bound_interval
  } invariant {
    forall j. 0 <= j < a.length - 1 -> before_interval a[j] a[j+1]
  }

  type lax_bound_union = {
     lax_a : array bound_interval
  } invariant {
    let a = lax_a in
    forall j. 0 <= j < a.length - 1 -> lax_a[j] <== lax_a[j+1]
  }

  predicate lax_mem_union (x:real) (lbu : lax_bound_union) =
    exists j. 0 <= j < lbu.lax_a.length /\ mem_r_interval x lbu.lax_a[j]

  predicate mem_union (x:real) (bu : bound_union) =
    exists j. 0 <= j < bu.a.length /\ mem_r_interval x bu.a[j]

  let rec lemma all_before (bu : bound_union) (i j : int) : unit
    requires { 0 <= i < j < bu.a.length }
    ensures { before_interval bu.a[i] bu.a[j] }
    variant { j - i }
  = if j = i+1 then () else all_before bu (i+1) j

  lemma mem_union_unique :
    forall x. forall bu. forall i. 0 <= i < bu.a.length -> mem_r_interval x bu.a[i] ->
      forall j. 0 <= j < i \/ i < j < bu.a.length -> not mem_r_interval x bu.a[j]

  let function lax_inj (bu : bound_union) : lax_bound_union
    ensures {forall x. mem_union x bu <-> lax_mem_union x result}
  = { lax_a = bu.a }

  let function lax_merge (lbu: lax_bound_union) (i : int) : lax_bound_union
    requires { 0 <= i < lbu.lax_a.length - 1}
    requires { lbu.lax_a[i] <.> lbu.lax_a[i+1] }
    ensures { result.lax_a.length = lbu.lax_a.length - 1 }
    ensures { forall x. lax_mem_union x result <-> lax_mem_union x lbu }
    ensures { forall j. 0 <= j < i -> result.lax_a[j] = lbu.lax_a[j] }
    ensures { forall j. i+1 <= j < lbu.lax_a.length - 1 ->
              result.lax_a[j] = lbu.lax_a[j+1] }
    ensures { result.lax_a[i] = lbu.lax_a[i]++lbu.lax_a[i+1] }
  =
    begin (* not necessary but make proof quicker *)
      let j = i+1 in
      assert { V.(lbu.lax_a[i].lower<=lbu.lax_a[j].lower<=lbu.lax_a[j].upper) };
      assert { V.(lbu.lax_a[j].lower <= lbu.lax_a[j].upper) };
      assert { not V.(lbu.lax_a[Int.(i+1)].upper < lbu.lax_a[i].lower) };
      assert { not (before_interval lbu.lax_a[i+1] lbu.lax_a[i]) }
    end;
    let na = replace_by_one lbu.lax_a (lbu.lax_a[i]++lbu.lax_a[i+1]) i (i+2) in
    { lax_a = na }

  let lemma relating_orders (i j : bound_interval)
    ensures {(i<==j /\ not (i<.>j)) -> i << j} = ()

  let lax_to_strict (lbu : lax_bound_union) : bound_union
    ensures { forall x. mem_union x result <-> lax_mem_union x lbu }
  =
    let ref i = 0 in
    let ref tmp = { lax_a = copy lbu.lax_a } in
    while i < tmp.lax_a.length - 1 do
      variant { tmp.lax_a.length - i }
      invariant { 0 <= i }
      (* we need to assure why3 that the type invariant is preserved *)
      invariant { forall j. 0 <= j < tmp.lax_a.length - 1 ->
                  tmp.lax_a[j] <== tmp.lax_a[j+1] }
      invariant { forall j. 0 <= j < i -> tmp.lax_a[j] << tmp.lax_a[j+1] }
      invariant { forall x. lax_mem_union x lbu <-> lax_mem_union x tmp }

      assert { not tmp.lax_a[i]<.>tmp.lax_a[i+1] -> tmp.lax_a[i] << tmp.lax_a[i+1] };
      if tmp.lax_a[i] <.> tmp.lax_a[i+1] then
        begin
        assert { tmp.lax_a[i] <== tmp.lax_a[i+1] };
        assert { i-1 >= 0 -> tmp.lax_a[i-1] << tmp.lax_a[i] };
        assert { i-1 >= 0 -> tmp.lax_a[i-1] << tmp.lax_a[i+1] };
        tmp <- lax_merge tmp i;
        assert { i-1 >= 0 -> tmp.lax_a[i-1] << tmp.lax_a[i] };
        end
      else
        i <- i + 1
    done;
    { a = tmp.lax_a }

  let function add_interval (int : bound_interval) (bu : bound_union) : bound_union
    ensures { true \/ (forall x. mem_union x result
                   <-> (mem_union x bu \/ mem_r_interval x int)) }
  =
    exception Return (array bound_interval) in
    try
      for i = 0 to bu.a.length - 1 do
        invariant { forall j. 0 <= j < i -> before_interval bu.a[i-1] int }
        if before_interval int bu.a[i] then
           let t = insert int bu.a i in
           assert { i > 0 -> before_interval t[i-1] t[i] }; (* quicker *)
           assert { forall j. 0 <= j < bu.a.length -> before_interval t[j] t[j+1] };
           raise (Return t)
        else if incl_interval bu.a[i] int then
           let t = copy bu.a in
           t[i] <- int;
           raise (Return t)
        else if incl_interval int bu.a[i] then
           raise (Return (copy bu.a))
        else if not (before_interval bu.a[i] int) then
           raise (Return (empty())); (* TODO *)
        assert {before_interval bu.a[i] int};
      done;
      raise (Return (insert int bu.a bu.a.length));
    with Return t -> { a = empty() }
    end;

    (*
       Plan:
        - lax unions
        - mem for lax unions
        - add interval to lax unions
        - merge lax union to get equivalent strict union
        - intersect interval with lax union
        -
    *)
end

