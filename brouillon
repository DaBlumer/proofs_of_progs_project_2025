(*module Q : Intf
    use real.Real
    use real.RealInfix
    
    type t = {
      p : int
      q : int
    } ensures { q <> 0 }
    
    function real (x : t) : real = x.p /. x.q

    
    predicate equal (a b : real) = (a.real = b.real)
    predicate (<=) (a:real) (b:real) = (a.real <=. b.real)
    predicate (<) (a:real) (b:real) = (a.real <. b.real)
    
    let (=) a b = a.p /. a.q = b.p /. b.q
    let (<=) (a b : real) : bool = (a <= b)
    let (<) = (<)
    
    
    use real.Abs
    let abs (a:t) : t = abs a
    ensures { result.real = abs a.real }

    type ord = Eq | Lt | Gt
    val compare (a:t) (b:t) : ord
        ensures {
            match result with
            | Eq -> equal a b | Lt -> a < b | Gt -> b < a
            end
        }

    let function (+) (a:t) (b:t) : t ensures { a.real +. b.real = result.real }
      = a +. b
    let function (-) (a:t) (b:t) : t ensures { a.real -. b.real = result.real }
      = a -. b
    let function (*) (a:t) (b:t) : t ensures { a.real *. b.real = result.real }
      = a *. b

    val function (/) (a:t) (b:t) : t
        requires { b.real <> 0.0 }
        ensures { result.real = a.real /. b.real }

    use real.Truncate
    use real.FromInt

    let function of_int (i : int) : t = (from_int i)

    function truncate (a : real) : int = Truncate.truncate a
    function floor (a:t) : int = Truncate.floor a
    function ceil (a:t) : int = Truncate.ceil a
end*)


(*module Q : Intf
    use real.Real
    use real.RealInfix
    
    type t = {
      p : int
      q : int
    } ensures { q <> 0 }
    
    function real (x : t) : real = x.p /. x.q

    
    predicate equal (a b : real) = (a.real = b.real)
    predicate (<=) (a:real) (b:real) = (a.real <=. b.real)
    predicate (<) (a:real) (b:real) = (a.real <. b.real)
    
    let (=) a b = a.p /. a.q = b.p /. b.q
    let (<=) (a b : real) : bool = (a <= b)
    let (<) = (<)
    
    
    use real.Abs
    let abs (a:t) : t = abs a
    ensures { result.real = abs a.real }

    type ord = Eq | Lt | Gt
    val compare (a:t) (b:t) : ord
        ensures {
            match result with
            | Eq -> equal a b | Lt -> a < b | Gt -> b < a
            end
        }

    let function (+) (a:t) (b:t) : t ensures { a.real +. b.real = result.real }
      = a +. b
    let function (-) (a:t) (b:t) : t ensures { a.real -. b.real = result.real }
      = a -. b
    let function (*) (a:t) (b:t) : t ensures { a.real *. b.real = result.real }
      = a *. b

    val function (/) (a:t) (b:t) : t
        requires { b.real <> 0.0 }
        ensures { result.real = a.real /. b.real }

    use real.Truncate
    use real.FromInt

    let function of_int (i : int) : t = (from_int i)

    function truncate (a : real) : int = Truncate.truncate a
    function floor (a:t) : int = Truncate.floor a
    function ceil (a:t) : int = Truncate.ceil a
end*)

(*module Q : Intf
    use real.Real
    use real.RealInfix
    
    type t = {
      p : int
      q : int
    } ensures { q <> 0 }
    
    function real (x : t) : real = x.p /. x.q

    
    predicate equal (a b : real) = (a.real = b.real)
    predicate (<=) (a:real) (b:real) = (a.real <=. b.real)
    predicate (<) (a:real) (b:real) = (a.real <. b.real)
    
    let (=) a b = a.p /. a.q = b.p /. b.q
    let (<=) (a b : real) : bool = (a <= b)
    let (<) = (<)
    
    
    use real.Abs
    let abs (a:t) : t = abs a
    ensures { result.real = abs a.real }

    type ord = Eq | Lt | Gt
    val compare (a:t) (b:t) : ord
        ensures {
            match result with
            | Eq -> equal a b | Lt -> a < b | Gt -> b < a
            end
        }

    let function (+) (a:t) (b:t) : t ensures { a.real +. b.real = result.real }
      = a +. b
    let function (-) (a:t) (b:t) : t ensures { a.real -. b.real = result.real }
      = a -. b
    let function (*) (a:t) (b:t) : t ensures { a.real *. b.real = result.real }
      = a *. b

    val function (/) (a:t) (b:t) : t
        requires { b.real <> 0.0 }
        ensures { result.real = a.real /. b.real }

    use real.Truncate
    use real.FromInt

    let function of_int (i : int) : t = (from_int i)

    function truncate (a : real) : int = Truncate.truncate a
    function floor (a:t) : int = Truncate.floor a
    function ceil (a:t) : int = Truncate.ceil a
end*)

(*

Turambar — 15/01/2025 10:34
L'énoncé du projet est en partie faux, pour ceux qui viendraient pas
Pour les fonctions strictement (dé)croissantes, la correction c'est "pour tout x, x € U -> op(x) € result" avec U l'union d'intervalle, et la complétude c'est montrer l'équivalence
le problème étant qu'une fonction croissante préserve pas nécessairement les intervalles

*)


  (*let ghost ndisj_carac_aux1 (i j : bound_interval) : real
    requires {ndisj_interval i j}
    ensures { mem_r_interval result i /\ mem_r_interval result j }
  =
    let (i,j) = if lax_before_interval i j then (i, j) else (j, i) in
    if V.(i.upper = j.lower) then
      i.upper.V.real
    else
      let y = V.(if i.upper <= j.upper then i.upper else j.upper) in
      V.(y.real +. j.lower.real)/. 2.

  let lemma ndisj_carac_aux2 (i j : bound_interval)
    requires {ndisj_interval i j}
    ensures {not disj_r_interval i j}
  = let _ = ndisj_carac_aux1 i j in ()*)


        (* assert { forall x. mem_r_interval x inter <-> *)
        (*                    mem_r_interval x int /\ mem_r_interval x a[i] }; *)
        (* label H in tmp <- replace_by_one tmp inter (length tmp) (length tmp); *)
        (* assert { forall x. gen_mem_union x tmp <-> *)
        (*                    gen_mem_sub_union x tmp 0 (length tmp - 1) \/ gen_mem_sub_union x tmp (length tmp - 1) (length tmp)}; *)
        (* assert { forall x. gen_mem_sub_union x tmp 0 (length tmp - 1) <-> gen_mem_union x (tmp at H) }; *)
        (* assert { tmp[length tmp - 1] = inter }; *)
        (* assert { forall x. gen_mem_sub_union x tmp (length tmp - 1) (length tmp) <-> mem_r_interval x inter }; *)
        (* assert { forall x. gen_mem_union x tmp <-> *)
        (*                    gen_mem_union x (tmp at H) \/ mem_r_interval x inter } *)


  let rec lemma csort_aux_1 (a b: array elt) (i j k l: int)
    requires { 0 <= i <= k <= l < j <= length a }
    requires { forall n. i <= n < j -> le a[l] a[n] }
    requires { exchange a b k l }
    ensures { forall n. i <= n < j -> le b[k] b[n] }
  =
    ()
