module Intf
    use real.RealInfix    use int.Int    use real.FromInt

    type t
    
    (*
      Adding an "axiom" stating that t is not empty for type variant purposes.
      This should be reasonable as we are trying to represent a field with the
      type t and so should always have the 0 and 1 representatives.
    *)
    val non_empty : t

    function real (q:t) : real    meta coercion function real

    predicate equal (a b:t) = (a.real = b.real)

    val (=) (a:t) (b:t) : bool ensures { equal a b = result }

    axiom equal_is_eq: forall a b. equal a b -> a = b

    predicate (<=) (a:t) (b:t) = (a.real <=. b.real)
    predicate (<) (a:t) (b:t) = (a.real <. b.real)

    val (<=) (a:t) (b:t) : bool ensures { result = (a <= b) }
    val (<) (a:t) (b:t) : bool ensures { result = (a < b) }

    use real.Abs
    val abs (a:t) : t
    ensures { result.real = abs a.real }

    type ord = Eq | Lt | Gt
    val compare (a:t) (b:t) : ord
        ensures {
            match result with
            | Eq -> equal a b | Lt -> a < b | Gt -> b < a
            end
        }

    val function (+) (a:t) (b:t) : t ensures { a.real +. b.real = result.real }
    val function (-) (a:t) (b:t) : t ensures { a.real -. b.real = result.real }
    val function (*) (a:t) (b:t) : t ensures { a.real *. b.real = result.real }

    val function (/) (a:t) (b:t) : t
        requires { b.real <> 0.0 }
        ensures { result.real = a.real /. b.real }
    
    axiom dense: forall a b : t. a < b -> exists c. a < c < b
    use real.Truncate

    val of_int (i : int) : t ensures { result.real = from_int i }

    val truncate (a:t) : int ensures { result = truncate a.real }
    val floor (a:t) : int ensures { result = floor a.real }
    val ceil (a:t) : int ensures { result = ceil a.real }
end